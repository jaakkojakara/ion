use std::fmt::Debug;

use bincode::{Decode, Encode};
use ion_common::net::NetworkPlayerInfo;
use std::hash::Hash;

use crate::core::UniverseFrameProps;
use crate::gfx::{GfxDebugData, GfxGlobalData, GfxSpriteData};
use crate::input::input_state::InputState;

use super::coordinates::ChunkLocation;
use super::universe::UniverseDataType;
use super::{FrameId, RenderFrameProps};

// ---------------------------------------------------------- //
// ----------------- World associated types ----------------- //
// ---------------------------------------------------------- //

/// Unique identifier for worlds within a universe.
pub type WorldId = u32;

/// User input commands mapped from physical input devices via key bindings.
///
/// Commands represent high-level user intentions like "move forward", "attack", or "open menu".
/// They are generated by the input system when specific key combinations are pressed,
/// and are then processed by the world to generate specific [`ActionType`] instances.
pub trait CommandType: 'static + Debug + Send + Sync + Clone + Copy + Eq + Hash + Encode + Decode<()> {}

/// Game actions that modify world state and are synchronized across the network.
///
/// Actions are the **only** way to modify world state to ensure deterministic gameplay.
///
/// ## Action Categories
///
/// Actions are divided into two categories based on `is_stateful()`:
///
/// ### Stateful Actions
/// - Modify game state (player movement, building placement, combat, etc.)
/// - Synchronized across all clients in multiplayer
/// - Handling must be deterministic
/// - Examples: player movement, item pickup, structure building, etc.
///
/// ### Stateless Actions
/// - Only affect local UI, camera, or debug visualization
/// - Not synchronized across network
/// - Can have client-specific behavior
/// - Examples: camera zoom, debug overlays, UI state changes, etc.
///
/// ## Network Synchronization
///
/// In multiplayer games:
/// 1. Each client generates actions from local Commands (or raw input)
/// 2. Stateful actions are sent to the server
/// 3. Server distributes actions to all clients
/// 4. All clients execute actions in the same order
/// 5. This maintains identical world state across all players
///
/// ## Performance Considerations
///
/// - Actions should be **small** as they are sent over network frequently
/// - Complex operations should be computed from simple action data
/// - Avoid embedding large data structures directly in actions
pub trait ActionType: 'static + Debug + Send + Sync + Clone + PartialEq + Encode + Decode<()> {
    fn is_stateful(&self) -> bool;

    fn send_to_active<W: WorldType<ActionType = Self>>(self, props: &RenderFrameProps<W>) {
        props.universe.send_action_to_active_world(self);
    }

    fn send_to_all<W: WorldType<ActionType = Self>>(self, props: &RenderFrameProps<W>) {
        props.universe.send_action_to_all_worlds(self);
    }
}

/// Data structure containing all information needed to render the game's user interface.
///
/// UI data is built by the active world each frame and sent to the render thread for display.
/// This separation allows the universe thread to focus on game logic while the render
/// thread handles UI presentation.
///
/// ## Design Principles
///
/// - **Complete**: Must contain all data needed to render UI without world access
/// - **Lightweight**: Copied/sent across threads every frame
/// - **Immutable**: UI data is a snapshot of a single universe frame
pub trait UiDataType: 'static + Debug + Send {}

// ---------------------------------------------------------- //
// ======================= World Trait ====================== //
// ---------------------------------------------------------- //

/// The main trait that defines a single game world or level.
///
/// A world represents a complete game environment - a level, area, dimension, or any
/// self-contained game space. Each world maintains its own game state, processes
/// actions independently, and can be activated/deactivated within a universe.
pub trait WorldType: 'static + Sized + Debug + Send {
    type CommandType: CommandType;
    type ActionType: ActionType;
    type UiDataType: UiDataType;
    type UniverseDataType: UniverseDataType<WorldType = Self>;

    /// Returns the unique identifier for this world.
    fn id(&self) -> WorldId;

    /// Returns the human-readable name of this world.
    fn name(&self) -> &str;

    /// Deserializes a world from a byte array.
    ///
    /// Used for loading saved worlds from disk or receiving world data
    /// over the network in multiplayer scenarios.
    /// Active player info just tells if the world is in server-only mode or if there is an active local player.
    /// The player may or may not be in this specific world.
    fn from_bytes(bytes: &[u8], active_player_info: Option<NetworkPlayerInfo>) -> Option<Self>;

    /// Serializes this world to a byte array.
    ///
    /// Used for saving worlds to disk or sending world data over
    /// the network in multiplayer scenarios.
    fn as_bytes(&self) -> Vec<u8>;

    /// Builds stateful actions from user input that modify game state.
    ///
    /// Stateful actions are synchronized across the network in multiplayer games
    /// and must be deterministic. They represent actual game events like player
    /// movement, item usage, building placement, etc.
    fn build_stateful_actions(
        &self,
        input: &InputState<Self::CommandType>,
        is_active_world: bool,
    ) -> Vec<Self::ActionType>;

    /// Builds stateless actions from user input that only affect local state.
    ///
    /// Stateless actions are not synchronized across the network and can have
    /// client-specific behavior. They typically affect UI, camera, debug visualizations,
    /// or other local-only state.
    fn build_stateless_actions(
        &self,
        input: &InputState<Self::CommandType>,
        is_active_world: bool,
    ) -> Vec<Self::ActionType>;

    /// Executes a universe frame update for this world.
    ///
    /// This is the core update method called once per universe frame.
    /// It processes all actions for this frame and updates the world state accordingly.
    fn execute_on_universe_frame(&mut self, props: UniverseFrameProps<Self>);

    /// Builds optimized render data for the graphics system.
    ///
    /// This method is called once per render frame for the active world only.
    /// It must return all data needed to render the world without accessing
    /// the world state again from the render thread.
    ///
    /// ## ⚠️ Critical Constraint
    /// **The logical world state MUST remain unchanged by this method.**
    /// Even though it takes `&mut self`, this is only for managing graphics
    /// caches and render optimizations. The logical game state must be identical
    /// before and after this call.
    ///
    /// ## Return Values
    ///
    /// ### [`GfxGlobalData`]
    /// Global rendering parameters like camera position, lighting settings,
    /// and frame-specific data needed by shaders.
    ///
    /// ### [`GfxSpriteData`]
    /// All sprites to be rendered, divided into two categories:
    ///
    /// #### Chunked Sprites (Static/Cached)
    /// - Sprites that rarely change (terrain, buildings, static objects)
    /// - Organized by chunk for efficient spatial culling
    /// - Cached by renderer; only update when chunks actually change
    /// - Very efficient for large worlds
    /// - Return `None` for unchanged chunks, `Some(sprites)` for modified chunks
    ///
    /// #### Dynamic Sprites (Per-Frame)
    /// - Sprites that move or change frequently (players, projectiles, effects)
    /// - Sent to GPU every frame (more expensive)
    /// - Use sparingly for performance
    ///
    /// ### [`GfxDebugData`]
    /// Debug visualizations like collision boxes, AI paths, performance overlays.
    /// Only rendered when debug mode is enabled.
    ///
    /// ## Performance Optimization
    /// - Minimize dynamic sprites (prefer chunked when possible)
    /// - Use spatial culling to avoid processing off-screen chunks
    /// - Cache expensive calculations between frames
    /// - Only rebuild chunk data when actually modified
    fn build_render_data(
        &mut self,
        frame: FrameId,
        cached: &[ChunkLocation],
    ) -> (GfxGlobalData, GfxSpriteData, GfxDebugData);

    /// Builds UI data for interface rendering.
    ///
    /// Called once per frame for the active world to generate all data
    /// needed to render the user interface. The UI data is sent to the
    /// render thread where it's used to draw menus, HUD elements, etc.
    fn build_ui_data(&self, frame: FrameId) -> Self::UiDataType;
}
